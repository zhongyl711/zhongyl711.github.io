## IPv4
[RFC文档地址](https://www.rfc-editor.org/rfc/rfc791)
可以参照协议/数据包分析

### Internet Header Format
**互联网头格式 ip层的头部格式**
```
0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Version|  IHL  |Type of Service|          Total Length         |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|         Identification        |Flags|      Fragment Offset    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Time to Live |    Protocol   |         Header Checksum       |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                       Source Address                          |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Destination Address                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```
### Version and IHL
Version和IHL是一个字节各占四位

Version 为协议版本

The Internet Header Length field indicates where the data begins.

Internet Header Length 是 Internet Header 的长度，以 32 位字为单位，指示数据开始的位置。请注意，正确标头的最小值为 5。

### Type of Service
The Type of Service field is used to indicate the type of

> 早期的 Type of Service 各个位置表示含义不一样
#### 早期
- **Bits 0-2**:  Precedence.
- **Bit    3**:  0 = Normal Delay,      1 = Low Delay.
- **Bits   4**:  0 = Normal Throughput, 1 = High Throughput.
- **Bits   5**:  0 = Normal Relibility, 1 = High Relibility.
- **Bit  6-7**:  Reserved for Future Use.

- **位 0-2**：优先级。
- **位 3**：0 = 正常延迟，1 = 低延迟。
- **位 4**：0 = 正常吞吐量，1 = 高吞吐量。
- **位 5**：0 = 正常可靠性，1 = 高可靠性。
- **第 6-7 位**：保留以备将来使用。

**Precedence 优先**
- 111 - Network Control
- 110 - Internetwork Control
- 101 - CRITIC/ECP
- 100 - Flash Override
- 011 - Flash
- 010 - Immediate
- 001 - Priority
- 000 - Routine


#### 简化版
**Type of Service (ToS)** 是一个在 IP 数据包头部中的字段，用于指示数据包的服务类型。这个字段最初被设计用于在 IP 层面提供服务质量 (QoS, Quality of Service) 控制，以便网络管理员可以指定数据包应该如何被处理。

在 IPv4 中，Type of Service 字段位于 IP 头部中，它占用一个字节 (8 位)，并且被分成几个部分：
- **Precedence（优先级）**: 占用了 3 位，用于指示数据包的优先级。
- **Delay（延迟）**: 1 位，用于指示数据包是否应该优化以减少延迟。
- **Throughput（吞吐量）**: 1 位，用于指示数据包是否应该优化以提高吞吐量。
- **Reliability（可靠性）**: 1 位，用于指示数据包是否应该优化以提高可靠性。
- **Cost（成本）**: 1 位，用于指示数据包是否应该优化以降低传输成本。
- **Unused（未使用）**: 1 位，保留未用。

在 IPv4 中，Type of Service 字段并没有得到广泛使用，因为许多网络设备并没有实现这些服务类型的区分。随着网络技术的发展，Type of Service 被新的字段取代，以提供更精细的 QoS 控制。

**在 IPv4 中的演变**

在较新的 IPv4 实现中，Type of Service 字段已经被 Differentiated Services Code Point (DSCP) 所取代。DSCP 占用了 Type of Service 字段中的前 6 位，并且定义了一种更简单的方法来标记数据包，以支持不同的服务等级。

**在 IPv6 中的变化**

在 IPv6 中，Type of Service 字段被重新命名为 Traffic Class，并且它占用两个字节 (16 位)。Traffic Class 字段不仅提供了 DSCP 的功能，还可以支持其他服务质量需求。

总之，Type of Service 是 IP 数据包头部中的一个字段，最初用于指示数据包的服务类型，但在现代网络中已经被 DSCP 和 Traffic Class 所取代，以提供更高级别的 QoS 控制。

### Flags and Fragment Offset
***前三位表示 Flags***

- **Bit 0**: reserved, must be zero 保留必须是 0
- **Bit 1**: (DF) 0 = May Fragment,  1 = Don't Fragment. 0 = 可能分段，1 = 不分段。 如果不分段，数据报长度过大，会被丢弃。用底层socket 就可以设置DF标志。
- **Bit 2**: (MF) 0 = Last Fragment, 1 = More Fragments. 0 = 最后一个片段，1 = 更多片段

***后十三位表示 Fragment Offset***

在IPv4头部，Fragment Offset字段占据了13位，用于指示数据报分段的偏移量，这个偏移量是以8字节为单位的。这允许数据报最大偏移量达到 
2^13−1=8191 个8字节块，即65528字节。这种设计是为了在数据包在网络中传输时，能够分成更小的片段，在到达目的地后能正确地重组原始数据包

**问题**

- **一.如果我发送了一个超过65528字节的包会怎样？**

尝试发送一个超过65528字节的IP数据包，那么会发生以下几种情况之一：

**分片**：如果IP数据包超过网络的最大传输单元（MTU），IP协议将会对数据包进行分片处理，使得每个片段都不超过MTU。对于IPv4，每个片段都会包含原始数据包的一部分，并且每个片段都将独立地传输到目的地。目的地主机将根据分片的偏移量和更多的信息来重新组装这些片段。然而，IPv4头部的Fragment Offset字段限制了单个数据包的分片数量，因为它只有13位，最大分片偏移量为65528字节。如果数据包大小超过这个限制，它将不能被正确分片和传输。

**丢弃和错误**：如果某个系统或设备无法处理或分片超过65528字节的数据包，这个数据包可能会被丢弃。在这种情况下，发送端可能会收到一个ICMP错误消息，如“Fragmentation Needed and DF Set”错误，指示数据包需要分片但DF（不分片）标志被设置。

**路径MTU发现**：许多现代网络实现了路径MTU发现机制，用来确定数据从源头到目的地的路径上最小的MTU，从而避免分片。如果发现路径MTU小于数据包的大小，IP层会通知发送应用减小数据包大小或启用分片。

因此，发送一个超过65528字节的数据包通常不是一个好主意，因为它可能导致传输问题或数据包被丢弃。在设计网络通信和数据传输时，了解和遵守MTU限制是非常重要的。

- **二.我上传一个大的压缩包那么肯定会超过65528字节，是如何处理的？**

当你上传一个大的压缩包时，其大小很可能会超过65528字节。不过，在现代网络通信中，处理大文件传输的问题主要依赖于更高层的协议和机制，而不仅仅是依赖于IP层的分片功能。这些更高层的协议包括但不限于TCP和应用层协议，它们提供了更加有效和可靠的数据传输方法：

**TCP分段**：当数据通过TCP协议传输时，TCP会负责将大型数据流分割成合适大小的段，以符合网络的MTU。TCP还会负责数据的重传、顺序管理和数据完整性检查。

**应用层分块**：许多应用层协议和文件传输服务实现了自己的数据分块和管理机制。例如，HTTP协议支持多部分数据传输，而FTP和其他文件传输协议也有自己的机制来处理大文件。

**重组和重传**：在接收端，无论是TCP还是其他协议，都会对接收到的数据段或片段进行重组，以重建原始数据。如果在数据传输过程中丢失了数据，协议会自动处理必要的重传。

因此，当你上传一个大于65528字节的压缩包时，通常不需要担心IP层的分片限制。传输过程中的分割、传输和重组都由TCP/IP协议栈中更高层的协议自动管理和优化。这确保了数据的有效传输和网络的高效使用。

- **三.tcp分段后可能ip还会分片？**

是的，确实如此。在数据传输过程中，TCP分段和IP分片是两个相互独立但可能同时发生的过程。这两者的关系可以这样理解：

**TCP分段**：TCP协议在传输大数据时会将数据分割成更小的段，每个段的大小通常会考虑到网络的最大传输单元（MTU），以避免IP层的分片。TCP还会确保每个段的可靠传输，通过确认和重传机制来处理数据丢失或错误的情况。

**IP分片**：尽管TCP会尝试根据MTU来分段数据，但在某些情况下，如果TCP段的大小超过了实际传输路径上某一点的MTU，IP层仍然需要对这些数据进行分片。例如，当数据包经过一个MTU较小的网络时，即使TCP已经按照一个较大的MTU进行了分段，IP层还是需要将这些数据包分片以适应较小的MTU。

因此，TCP分段是为了优化传输效率并减少IP分片的需要，而IP分片则是为了应对不同网络条件下MTU的限制。理想情况下，通过路径MTU发现等技术，可以最大限度地减少IP层需要进行分片的情况，从而提高网络效率和数据传输速度。

- **四.应用层如果考虑分块了 是不是也会兼顾tcp层尽量不分段？**

是的，应用层在设计数据分块策略时通常也会考虑到下层协议，尤其是TCP层的行为，以优化整体网络性能和提高数据传输效率。以下是几个关键点说明应用层如何考虑TCP分段：

**考虑MTU大小**：应用层可以设计其数据块大小以适配网络的MTU，尽量避免在IP层发生分片。例如，应用层可以通过路径MTU发现（PMTUD）来了解当前传输路径的最小MTU，并据此调整其数据块的大小。

**优化数据包大小**：在不少情况下，应用层会选择一个标准的数据块大小，例如TCP层常见的MSS（Maximum Segment Size），这是去除IP和TCP头部后，能够适配大多数网络MTU的数据大小。这样做可以最大限度地减少IP层的分片需求。

**流控制和拥塞控制**：应用层在设计分块策略时，还会考虑TCP的流控制和拥塞控制机制，以避免发送过多数据而导致网络拥堵。合理的数据块大小可以帮助平滑数据流并避免突发的大量数据传输，从而维护网络稳定性和高效性。

**应用层协议优化**：一些高级应用层协议，如**HTTP/2**和**QUIC**，已经内置了更加智能的数据流管理机制，这些机制可以基于网络条件动态调整数据流的大小和速率，进一步减少了需要在TCP层进行分段的情况。

综上，应用层在处理数据分块时通常会尽量兼顾TCP层的行为，通过智能调整数据块大小和发送策略，以优化数据传输的效率和可靠性。这样的设计可以减少网络层面的复杂性和潜在的性能问题。

- **五.应用层的是不是抓包后看见叫chunk的那种？**

是的，你提到的“chunk”常见于某些应用层协议中，特别是在HTTP协议的上下文中。在HTTP传输中，使用分块传输编码（chunked transfer encoding）可以动态地发送数据块，这是一种允许发送方在知道全部内容大小之前就开始传输数据的机制。以下是一些关键点：

**分块传输编码**：当使用HTTP协议传输大型数据或流式数据时，可以采用分块传输编码。这种方式允许服务器将响应体分为多个部分（即“chunks”）逐个发送。每个chunk的开始都会标明该部分的大小，后面跟随实际的数据，然后是一个CRLF（回车换行）结束符。

**抓包看见的chunk**：当你使用网络抓包工具（如Wireshark）抓取HTTP流量时，如果遇到使用分块传输编码的HTTP响应，你会看到分块的数据。每个数据块的前面都有一个长度标识，表示该块的大小（通常是十六进制表示），然后是数据内容，块结束后有一个CRLF。最后一个块的长度为0，表示数据发送完毕。

**优点**：分块传输编码的优点是它允许服务器开始发送动态生成的内容而不必先计算出整个响应的长度。这对于流媒体和大文件传输特别有用，因为它减少了等待时间，允许客户端开始处理数据而不必等待所有数据都到齐。

**应用场景**：分块传输编码广泛应用于视频流、大文件下载和实时数据传输等场景，它使得服务器能够更有效地管理内存，同时提供更流畅的用户体验。

所以，当你在抓包工具中看到“chunk”这样的记录时，它通常指的是应用层正在使用分块传输编码的数据。这种方法有助于更灵活地处理数据传输，特别是在数据大小未知或动态变化时.

### Time to Live （TTL）

生存时间（Time To Live，TTL）是IPv4协议中的一个字段，用于控制数据报在网络中的传播时间。
此字段表示允许数据报在互联网系统中保留的最长时间。如果此字段包含值零，则必须销毁数据报。此字段在 Internet 标头处理中被修改。时间以秒为单位进行测量，但由于每个处理数据报的模块都必须将 TTL 至少减少 1，即使它在不到一秒的时间内处理数据报，因此只能将 TTL 视为数据报可能存在的时间的上限。其目的是使无法送达的数据报被丢弃，并限制最长数据报生存期。

**实际上**

Time to Live（TTL）这个术语原本指的确实是数据在网络中可以存在的时间，但在技术实现上，它通常被用作一个计数器，限制数据包在网络中可以经过的最大路由器（跳数）数量。每当数据包在网络中经过一个路由器时，其TTL值就会减一。当TTL值减至0时，数据包就会被丢弃，并且发送一个ICMP超时消息到发送者，防止数据包在网络中无限循环。

具体来说，TTL的作用包括：

**防止循环**：TTL最初的设计目的是防止在网络配置错误或路由环路情况下，数据包在网络中无限循环。

**网络范围控制**：通过设置TTL值，发送者可以在一定程度上控制数据包应该到达的网络范围。例如，在某些网络诊断工具（如traceroute）中，通过逐步增加TTL值，可以追踪数据包通过的路径。

**资源管理**：限制数据包的生存时间还有助于网络资源的管理，避免过时的数据包占用网络和路由器资源。

因此，虽然名为“生存时间”，TTL的实际作用更多是控制数据包可以经过的路由器数量，以及它在网络中可以传播的最大跳数。这是网络协议设计中一个重要的安全和效率机制。

常见的TTL初始值有：
- **64**：这是很多Unix和Linux系统中的默认值，包括Mac OS。
- **128**：Windows操作系统通常使用128作为默认的TTL值。
- **255**：一些路由器和网络硬件可能会使用255作为默认TTL值。

### Protocol

此字段表示互联网数据报的数据部分中使用的下一级协议。
这是一个协议编号的值，需要参考对照表找到对应协议 https://www.rfc-editor.org/rfc/rfc790

### Header Checksum

仅在标头上显示校验和。由于某些标头字段会发生变化（例如，生存时间），因此在处理互联网标头的每个点都会重新计算和验证。

**校验和算法为**：

The checksum field is the 16 bit one's complement of the one's
complement sum of all 16 bit words in the header.  For purposes of
computing the checksum, the value of the checksum field is zero.

校验和字段是标头中所有 16 位字的 1 位补码和的 16 位补码。为了计算校验和，校验和字段的值为零。

This is a simple to compute checksum and experimental evidence
indicates it is adequate, but it is provisional and may be replaced
by a CRC procedure, depending on further experience.

这是一个易于计算的校验和，实验证据表明它是足够的，但它是暂时的，可能会被 CRC 程序取代，具体取决于进一步的经验。

```
校验和计算过程解释 （这一段信息未分析报文去计算，有时间可以详细分析）

“校验和字段是标头中所有 16 位字的 1 位补码和的 16 位补码”这句话的意思是：

将IPv4头部中的所有字段（每个字段都是16位，最后如果有不足16位的部分则补足到16位）相加，包括校验和字段在内，但在计算时校验和字段的值视为0。
将这些16位数值相加时，如果产生了进位，则将进位加回到最低位（也就是所谓的“环绕”或“回卷”）。
最后，将得到的总和取一的补码（即将所有位反转）得到校验和。
这个校验和有助于接收方检测数据在传输过程中是否发生了错误。


IPv4头部通常包含以下几个字段：

版本（4位）：IPv4使用的版本号为4。
头部长度（4位）：IPv4头部的长度，单位是32位字。
服务类型（8位）：用于区分服务的优先级。
总长度（16位）：整个IP数据包的长度，包括头部和数据。
标识（16位）：用于标识分片的唯一数据包。
标志（3位）和片偏移（13位）：用于数据包分片和重组。
生存时间TTL（8位）：数据包在网络中可以通过的最大路由数。
协议（8位）：指示数据部分使用哪种协议，如TCP或UDP。
头部校验和（16位）：用于检查头部信息是否在传输过程中被更改。
源IP地址（32位）和目标IP地址（32位）：发送方和接收方的IP地址。
通过对这些字段的总和进行一的补码求和，然后再取一的补码，就得到了头部的校验和。这种方法旨在快速有效地检测数据传输错误。
```

### Source Address

32位 4字节

源ip地址 以 协议/数据包 中的报文数据为例 对应的地址为 192.168.100.33

### Destination Address

32位 4字节

目标ip地址 以 协议/数据包 中的报文数据为例 对应的地址为 192.168.8.7

### options
在IPv4协议中，IP头部的Options字段是一个可选字段，用于携带附加的信息或提供特殊的服务。这个字段在IPv4头部中是一个变长字段，长度不定，最多可以占据40字节。Options字段的存在是为了提供灵活性，以便在网络中实现特定的功能或进行实验。

Options字段的结构如下：

- **Option Kind**：指示选项的类型。
- **Option Length**：指示该选项的总长度（包括类型和数据）。
- **Option Data**：根据选项类型的不同，这里可以包含不同的数据。
常见的Options类型包括：

- **No Operation (NOP)**：值为0，仅作为一个填充选项，不携带任何数据。
- **End of Option List (EOL)**：值为1，表示选项列表的结束。
- **Security**：用于携带安全相关信息。
- **Record Route (RR)**：记录数据包经过的每个路由器的地址。
- **Timestamp (TS)**：记录数据包经过每个路由器的时间戳。
- **Loose Source Routing (LSR)**：允许指定数据包必须经过的某些IP地址，但不强制遵循顺序。
- **Strict Source Routing (SSR)**：指定数据包必须按照指定顺序经过的IP地址。

由于Options字段的存在增加了数据包头部的复杂性，并且大多数路由器不支持所有选项，因此它在现代网络中并不常用。实际上，许多路由器被配置为忽略Options字段，以简化处理过程并提高效率。

在IPv6协议中，Options字段的概念被保留了下来，但是采用了不同的方法来处理扩展头部，这些扩展头部提供了类似的功能，但更加灵活和模块化。

**示例**

例如，如果要记录数据包经过的路径，可以使用Record Route选项。当数据包经过每个路由器时，路由器会在数据包中添加自己的地址，这样数据包返回时就可以看到完整的路径。

**注意事项**

Options字段很少在生产环境中使用，因为大多数路由器都配置为忽略这些选项。
使用Options字段可能会导致数据包大小超过最大传输单元（MTU），从而导致分片。
许多网络设备和操作系统默认不支持Options字段，除非特别配置。
总之，Options字段在IPv4头部中是一个可选字段，用于携带附加信息或实现特殊功能。虽然它在历史上有一定的作用，但在现代网络中使用较少。

### padding

IPv4协议中，如果IP数据包的长度不能被4字节整除，则需要填充字节。填充字节的值可以是任何值，但通常为0。填充字节的作用是为了使IP数据包的长度能够被4字节整除，以便于后续的IP数据包处理。

### 注意事项 option 和 padding

在现代网络中，IPv4头部的选项和填充很少使用，大多数数据包都使用标准的20字节头部。这一趋势简化了网络操作，提高了效率，并减少了不必要的复杂性。
