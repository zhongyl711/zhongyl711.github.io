# Base64编码
Base64 是一种用64个字符表示任意二进制数据的编码方法，广泛用于在需要以文本形式存储或传输二进制数据的场合，如在电子邮件、XML或JSON数据中。Base64编码选用了64个字符：大写字母A-Z、小写字母a-z、数字0-9，加上两个符号+和/，共计64个字符，等号=用作填充字符。

## Base64编码的过程可以概述如下

**二进制数据分组**：首先，原始二进制数据被分割成每组3个字节（共24位）的小组。如果最后一组不足3个字节，会添加额外的0位（填充位）以使其达到24位。

**转换为64进制**：每组24位接着被划分为4个6位的小组。这些6位的值将用于在Base64字符表中查找对应的字符。

**编码输出**：每个6位的小组对应Base64表中的一个字符，将这些字符连续排列起来，就形成了原始数据的Base64编码形式。如果原始数据的字节数不是3的倍数，则在编码的末尾会添加一个或两个=字符作为填充，以使编码的总长度成为4的倍数。

## Base64编码的特点包括

**编码效率**：Base64编码后的数据比原始数据大约增加1/3。每3个字节的数据经过Base64编码后会变成4个字符。

**可读性**：由于编码仅使用可打印字符，因此编码后的数据可以在不支持二进制的文本系统中安全地传输和存储。

**通用性**：Base64编码广泛应用于多种场合，包括电子邮件中的MIME编码、数据URL、HTTP基本认证等。

尽管Base64编码非常有用，但它不是一种加密方法，也不应该用于安全敏感的数据传输，因为编码后的数据可以很容易地被解码回原始形式。

## 例子
### base64码表
```js
const base64Talbe = [
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    '+', '/'
]
```
### 字符串转base64的例子
```js
// 以数字 1 为例子 对应unicode位置 49 小于128 ASCII范围 对应utf8编码 不变
// 49 二进制
'00110001'
// 1.分割三个字节，不足24位 补 0，这一步的目的是形成完整的分组
00110001 00000000 00000000
// 2.划分6位一小组
001100 010000 000000 000000
// 3.划分后二进制数据转10进制 [12, 16, 0, 0]，在 base64Talbe 中找到对应位置的字符可以得到 MQAA
// 注意：AA是填充字符，最后会被替换成 = 阅读下文
// 4.替换MQAA中填充字符，得到最终结果
"MQ=="
```
``` info
Base64编码的填充规则确实有点绕。

首先，重点是Base64编码将3个字节的原始数据转换为4个Base64字符。
这是因为每个Base64字符只能表示6位（2^6=64），而每个字节包含8位。
所以，3个字节共24位可以被等分为4组，每组6位，对应于4个Base64字符。

当原始数据不足3个字节时，Base64编码会添加额外的0位（称为填充位），
以确保能够形成完整的6位分组。
这些填充位只是为了形成完整的分组，并不代表原始数据的一部分。
因此，当这些额外的0位被编码为Base64字符时，
它们会被转换为Base64表中的第一个字符，即A，因为二进制的000000对应于Base64中的A。

然而，这里的关键是区分填充位和填充字符。
填充位是在编码过程中添加到原始二进制数据中的额外0位，
以形成完整的6位分组。
而填充字符（=）是在Base64编码的字符串中添加的，
用于标示原始数据的实际结束，
并保证Base64字符串总长度是4的倍数。

对于只有1个字节的原始数据（比如1的ASCII码），在转换为二进制并添加填充位后，
会形成两个完整的6位分组（第一个分组来自原始数据，第二个分组全为填充位），
对应于两个Base64字符。剩余的两个6位分组（全为填充位）也会被转换为Base64字符A。
但是，这里的AA实际上表示原始数据之后添加的填充位，而不是原始数据的一部分。

因此，为了区分这些因填充位转换得到的Base64字符（如AA）和原始数据的实际结束，
Base64编码在最后添加=字符作为填充字符。
在只有1个字节的原始数据的情况下，会添加两个=，
以表示最后两个Base64字符实际上是由填充位转换来的，
而不是由原始数据转换来的。

所以，对于字符1的Base64编码，我们得到MQ==而不是MQAA。
MQ对应于原始数据，而==表示除了MQ之外的部分实际上是由填充位而不是原始数据转换来的。

也就是说替换字符=会替换 替换位的字符A（注意是替换位的）
```