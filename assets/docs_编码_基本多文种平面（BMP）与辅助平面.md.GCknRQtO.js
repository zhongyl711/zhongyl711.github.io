import{_ as a,o as s,c as i,R as n}from"./chunks/framework.vB1haF5z.js";const g=JSON.parse('{"title":"基本多文种平面（BMP）与辅助平面","description":"","frontmatter":{},"headers":[],"relativePath":"docs/编码/基本多文种平面（BMP）与辅助平面.md","filePath":"docs/编码/基本多文种平面（BMP）与辅助平面.md"}'),t={name:"docs/编码/基本多文种平面（BMP）与辅助平面.md"},e=n(`<h1 id="基本多文种平面-bmp-与辅助平面" tabindex="-1">基本多文种平面（BMP）与辅助平面 <a class="header-anchor" href="#基本多文种平面-bmp-与辅助平面" aria-label="Permalink to &quot;基本多文种平面（BMP）与辅助平面&quot;">​</a></h1><h2 id="基本多文种平面-bmp" tabindex="-1">基本多文种平面（BMP） <a class="header-anchor" href="#基本多文种平面-bmp" aria-label="Permalink to &quot;基本多文种平面（BMP）&quot;">​</a></h2><p>基本多文种平面（Basic Multilingual Plane, BMP）是 Unicode 字符集中的第一个平面，也被称为平面0。</p><p>Unicode标准为了能够编码世界上所有的字符，定义了一个从0到0x10FFFF的编码空间，这个空间被分割成17个平面，每个平面包含65,536（即16位或2字节能表示的最大数值）个码点。这些平面编号从0到16，其中第0平面称为“基本多语言平面”（Basic Multilingual Plane, BMP），剩余的16个平面（从1到16）被称为“辅助平面”（Supplementary Planes）。</p><h3 id="特点" tabindex="-1">特点 <a class="header-anchor" href="#特点" aria-label="Permalink to &quot;特点&quot;">​</a></h3><p>最早被广泛实现和使用，因此拥有最广泛的软件和字体支持。</p><p><strong>码点范围</strong>：BMP 包括从 U+0000 到 U+FFFF 的字符，共65536个字符。<br><strong>字符覆盖</strong>：BMP 包含了大多数现代文字系统的字符，包括所有的拉丁字符、希腊字符、西里尔字符、大部分汉字、平假名、片假名、韩文音节字符等。<br><strong>特殊区域</strong>：BMP 也包含了一系列特殊用途的区块，如控制字符、格式字符、专用区域和代理对的高位和低位区域。<br><strong>与编码的关系</strong>：在 UTF-16 编码中，BMP 内的字符直接用一个16位代码单元表示，而超出 BMP 的字符则通过一对16位的代理项（即所谓的代理对）来表示。</p><h3 id="重要性" tabindex="-1">重要性 <a class="header-anchor" href="#重要性" aria-label="Permalink to &quot;重要性&quot;">​</a></h3><p><strong>广泛使用</strong>：由于 BMP 包含了大多数常用字符，绝大多数文本处理任务只需涉及 BMP 内的字符即可。<br><strong>兼容性</strong>：在 Unicode 引入代理对机制之前，许多系统和应用程序仅设计为处理 BMP 内的字符，这使得 BMP 内的字符在实际应用中尤为重要。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>BMP 的设计旨在确保最常用的字符能够以最高的效率进行编码和处理，特别是在早期的 Unicode 实现和那些仅支持16位字符编码的系统中。随着 Unicode 标准的发展和扩展，超出 BMP 的字符也变得越来越重要，但 BMP 内的字符在日常应用中仍占据主导地位。</p></div><h2 id="辅助平面" tabindex="-1">辅助平面 <a class="header-anchor" href="#辅助平面" aria-label="Permalink to &quot;辅助平面&quot;">​</a></h2><h3 id="特性" tabindex="-1">特性 <a class="header-anchor" href="#特性" aria-label="Permalink to &quot;特性&quot;">​</a></h3><p>码点范围：从0x10000到0x10FFFF，共16个平面，每个平面包含65,536个码点。 编号：从1到16，分别称为“辅助平面-1”（Supplementary Multilingual Plane, SMP）到“辅助平面-16”（Supplementary Private Use Area-B, SPUA-B）。 包含：少用的文字、历史文字、音乐符号、数学符号、象形文字、私有使用区等。</p><h3 id="辅助平面的具体应用" tabindex="-1">辅助平面的具体应用 <a class="header-anchor" href="#辅助平面的具体应用" aria-label="Permalink to &quot;辅助平面的具体应用&quot;">​</a></h3><h4 id="辅助多语言平面-smp-plane-1" tabindex="-1">辅助多语言平面（SMP, Plane 1）： <a class="header-anchor" href="#辅助多语言平面-smp-plane-1" aria-label="Permalink to &quot;辅助多语言平面（SMP, Plane 1）：&quot;">​</a></h4><p>码点范围：0x10000 - 0x1FFFF<br> 包括：哥特文字、德塞雷特文字、数学扩展字符、历史语言文字等。</p><h4 id="辅助表意文字平面-sip-plane-2" tabindex="-1">辅助表意文字平面（SIP, Plane 2）： <a class="header-anchor" href="#辅助表意文字平面-sip-plane-2" aria-label="Permalink to &quot;辅助表意文字平面（SIP, Plane 2）：&quot;">​</a></h4><p>码点范围：0x20000 - 0x2FFFF<br> 包括：中日韩（CJK）统一表意文字扩展B、C、D、E、F区等。</p><h4 id="扩展表意文字平面-tip-plane-3" tabindex="-1">扩展表意文字平面（TIP, Plane 3）： <a class="header-anchor" href="#扩展表意文字平面-tip-plane-3" aria-label="Permalink to &quot;扩展表意文字平面（TIP, Plane 3）：&quot;">​</a></h4><p>码点范围：0x30000 - 0x3FFFF<br> 主要为未来的CJK表意文字扩展保留。</p><h4 id="其他平面-4-14" tabindex="-1">其他平面（4-14）： <a class="header-anchor" href="#其他平面-4-14" aria-label="Permalink to &quot;其他平面（4-14）：&quot;">​</a></h4><p>目前大部分未被广泛使用，保留用于未来扩展。</p><h4 id="私有使用区平面-pua-a-plane-15和pua-b-plane-16" tabindex="-1">私有使用区平面（PUA-A, Plane 15和PUA-B, Plane 16）： <a class="header-anchor" href="#私有使用区平面-pua-a-plane-15和pua-b-plane-16" aria-label="Permalink to &quot;私有使用区平面（PUA-A, Plane 15和PUA-B, Plane 16）：&quot;">​</a></h4><p>码点范围：0xF0000 - 0x10FFFF<br> 用途：供个人或私有组织按需定义字符，不被Unicode标准正式分配。</p><p>辅助平面的引入，使得Unicode能够提供足够的空间来编码几乎所有已知的字符系统，包括那些非常罕见或专用的字符，确保了Unicode的全面性和扩展性。由于辅助平面中的字符相对不常用，因此在实际应用中可能会遇到字体和软件支持的限制。</p><h2 id="代理项-代理对" tabindex="-1">代理项（代理对） <a class="header-anchor" href="#代理项-代理对" aria-label="Permalink to &quot;代理项（代理对）&quot;">​</a></h2><p>在Unicode编码中，高低代理项（High and Low Surrogate Pairs）是一种特殊的编码机制，用于表示超出基本多语言平面（BMP，即码点范围0x0000到0xFFFF之间的字符）的Unicode字符。这些字符的码点范围从0x10000到0x10FFFF，位于所谓的辅助平面（Supplementary Planes）内。</p><h3 id="高低代理项分别位于两个专门的unicode区块内" tabindex="-1">高低代理项分别位于两个专门的Unicode区块内： <a class="header-anchor" href="#高低代理项分别位于两个专门的unicode区块内" aria-label="Permalink to &quot;高低代理项分别位于两个专门的Unicode区块内：&quot;">​</a></h3><p>高代理项（High Surrogates）范围从0xD800到0xDBFF。<br> 低代理项（Low Surrogates）范围从0xDC00到0xDFFF。</p><p>要从一对高低代理项计算出原始的Unicode码点，可以使用以下公式：</p><div class="language-code vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">code</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>实际码点 = (高代理项值 - 0xD800) * 0x400 + (低代理项值 - 0xDC00) + 0x10000</span></span></code></pre></div><p>这里的“高代理项值”和“低代理项值”分别指的是高代理项和低代理项的Unicode码点值。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 不再BMP范围内的 一个文字 一个表情</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> char</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;𠮷&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> str</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;😊&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(char.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(str.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 对于这种需要使用代理对表示的 可以使用charCodeAt方法获取高低代理项的值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">char.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">charCodeAt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 55362 输出代理对的高代理项的代码单元</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">char.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">charCodeAt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 57271 输出代理对的低代理项的代码单元</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 想获取实际码点可以根据上面公式计算 或者使用 codePointAt方法获取实际码点值</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">55362</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0xD800</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0x400</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">57271</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0xDC00</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0x10000</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 134071</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">char.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">codePointAt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 134071</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在JavaScript中，一个字符（比如&#39;a&#39;）通常会占用两个字节。这是因为JavaScript内部使用UTF-16编码来表示字符串，而UTF-16是一种变长编码，它使用一个或两个16位的编码单元（即2或4个字节）来表示一个字符。</p><p>对于基本多文种平面（BMP）内的字符，包括所有的ASCII字符和许多其他常用字符，每个字符都会被编码为一个16位的单元。因此，像&#39;a&#39;这样的ASCII字符，在JavaScript中会占用16位，即2个字节。</p><p>然而，对于辅助平面（也称为非BMP字符）内的字符，比如某些表情符号、历史文字、音乐符号和特殊用途的符号，它们会被编码为两个16位的编码单元，即所谓的代理对，占用4个字节。</p><p>简单来说，大多数常见的字符（包括所有的ASCII字符）在JavaScript中占用2个字节，但更复杂或不常用的字符可能会占用4个字节。</p><p><strong>charCodeAt()</strong> 和 <strong>codePointAt()</strong> 是 JavaScript 中的字符串方法，它们都用于获取字符串中某个位置的字符的编码值，但它们在处理某些 Unicode 字符时的行为不同，尤其是对于那些超出基本多文种平面（BMP）的字符，也就是那些 Unicode 码点大于 0xFFFF 的字符。</p><h4 id="charcodeat" tabindex="-1">charCodeAt() <a class="header-anchor" href="#charcodeat" aria-label="Permalink to &quot;charCodeAt()&quot;">​</a></h4><p>charCodeAt() 方法返回指定索引处字符的 UTF-16 代码单元值（即16位数字）。对于 BMP 范围内的字符（码点在 U+0000 至 U+FFFF 之间），charCodeAt() 返回的值即是该字符的 Unicode 码点。<br> 对于位于辅助平面（即码点大于 U+FFFF 的字符）的字符，charCodeAt() 无法直接返回完整的 Unicode 码点，因为这些字符在 UTF-16 中是通过一对16位的代码单元（称为代理对）表示的。在这种情况下，charCodeAt() 只会返回代理对中的高代理项或低代理项的代码单元。</p><h4 id="codepointat" tabindex="-1">codePointAt() <a class="header-anchor" href="#codepointat" aria-label="Permalink to &quot;codePointAt()&quot;">​</a></h4><p>codePointAt() 方法是在 ECMAScript 2015（ES6）中引入的，它可以正确处理整个 Unicode 范围的字符，包括 BMP 范围外的字符。当调用 codePointAt() 方法时，如果指定位置是一个代理对的起始部分，它会正确地返回整个代理对表示的字符的完整 Unicode 码点。<br> 对于 BMP 内的字符，codePointAt() 和 charCodeAt() 返回相同的结果。但对于那些需要通过代理对表示的字符，codePointAt() 能返回实际的 Unicode 码点，而不仅仅是代理对中的一个代码单元。</p></div><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-label="Permalink to &quot;&quot;">​</a></h3><p>通过代理项这种方式，Unicode能够使用16位的编码单元（如UTF-16）来表示那些超出基本多语言平面的字符，从而扩展了Unicode的表示范围，使其能够包含多达超过100万个字符的巨大字符集。</p>`,36),h=[e];function l(p,r,o,k,d,c){return s(),i("div",null,h)}const E=a(t,[["render",l]]);export{g as __pageData,E as default};
