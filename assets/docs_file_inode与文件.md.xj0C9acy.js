import{_ as i,o,c as e,R as l}from"./chunks/framework.jG2La8vi.js";const m=JSON.parse('{"title":"inode与文件","description":"","frontmatter":{},"headers":[],"relativePath":"docs/file/inode与文件.md","filePath":"docs/file/inode与文件.md"}'),n={name:"docs/file/inode与文件.md"},t=l('<h1 id="inode与文件" tabindex="-1">inode与文件 <a class="header-anchor" href="#inode与文件" aria-label="Permalink to &quot;inode与文件&quot;">​</a></h1><h2 id="了解目录项-directory-entries" tabindex="-1">了解目录项 directory entries <a class="header-anchor" href="#了解目录项-directory-entries" aria-label="Permalink to &quot;了解目录项 directory entries&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">INFO</p><p>在Unix和类Unix系统中（如Linux），文件路径和inode号之间的对应关系实际上存储在文件系统的目录结构中。这种结构不是一个单独的表，而是通过目录项（directory entries）来实现的。以下是这种关系的基本工作原理：</p><p>目录项（Directory Entries）</p><ul><li>每个目录项将一个文件名（或目录名）与一个inode号关联起来。</li><li>当你创建一个文件时，系统在包含该文件的目录中创建一个新的目录项。这个目录项包含文件的名称和指向文件实际数据和元数据的inode号。</li><li>目录本身也是一种文件，它的数据部分包含了该目录下所有文件的目录项。</li></ul><p>目录文件</p><ul><li>目录实际上是一种特殊类型的文件。当你查看一个目录时，你实际上是在读取这个特殊文件的内容，这个内容就是一系列的目录项。</li><li>每个目录项至少包含两个部分：文件名和对应的inode号。</li><li>当你通过文件路径访问文件时，文件系统会沿着路径从根目录开始，遍历每个子目录的目录项，直到找到对应的文件名和inode号。</li></ul><p>举个例子 假设你有一个文件路径 /home/user/document.txt：</p><ul><li>/ 是根目录，它有一个目录项指向 home 目录的inode。</li><li>在 home 目录的目录项中，有一个指向 user 目录的inode。</li><li>最后，在 user 目录的目录项中，找到一个指向 document.txt 文件的inode。</li></ul><p>这种目录结构的设计使得文件系统能够高效地管理文件和目录，同时允许文件（或目录）在不同位置有多个名称（即硬链接）。每个文件都由其inode表示，而目录项提供了从文件名到inode的映射。</p></div><h2 id="了解inode-bitmap" tabindex="-1">了解inode bitmap <a class="header-anchor" href="#了解inode-bitmap" aria-label="Permalink to &quot;了解inode bitmap&quot;">​</a></h2><p>Inode号和Inode Bitmap</p><ul><li>Inode号：这是文件系统分配给每个文件和目录的唯一标识符。它用于标识文件系统中的每个inode。这个号码通常是一个整数。</li><li>Inode Bitmap：这是一个位图，用于跟踪文件系统中哪些inode是已使用的，哪些是空闲的。inode bitmap中的每一位对应一个特定的inode号。 对应关系：在inode bitmap中，位置（比如，第5位）是用来标记特定inode（比如，inode号为5）的使用状态。</li></ul><table><thead><tr><th>inode number</th><th>flag</th></tr></thead><tbody><tr><td>00000101</td><td>1</td></tr><tr><td>00110111</td><td>1</td></tr><tr><td>00111110</td><td>0</td></tr></tbody></table><h2 id="创建文件" tabindex="-1">创建文件 <a class="header-anchor" href="#创建文件" aria-label="Permalink to &quot;创建文件&quot;">​</a></h2><p>在Unix或类Unix文件系统中创建新文件时，文件系统会从inode bitmap中找到一个未使用的inode号来分配给这个新文件。这个过程通常包括以下几个步骤：</p><h3 id="创建文件时的inode分配过程" tabindex="-1">创建文件时的inode分配过程 <a class="header-anchor" href="#创建文件时的inode分配过程" aria-label="Permalink to &quot;创建文件时的inode分配过程&quot;">​</a></h3><p><strong>1. 查找空闲inode：</strong></p><ul><li>文件系统会检查inode bitmap，寻找一个标记为0（表示未使用）的位。</li><li>找到的第一个空闲位对应的inode号就是将要分配给新文件的inode。</li></ul><p><strong>2. 更新inode bitmap：</strong></p><ul><li>一旦找到空闲的inode号，文件系统会在inode bitmap中将对应的位设置为1，表示这个inode现在已被占用。</li></ul><p><strong>3. 初始化inode：</strong></p><ul><li>文件系统接着初始化这个inode，设置文件的元数据，如文件类型、大小、权限、所有者信息以及数据块指针等。</li><li>这个初始化的inode代表了新创建的文件。</li></ul><p><strong>4. 更新目录项：</strong></p><ul><li>文件系统还需要在包含新文件的目录中创建一个新的目录项，将新文件的名称与分配的inode号关联起来。</li></ul><p><strong>5. 分配数据块（如果需要）：</strong></p><ul><li>如果新文件需要存储数据（如非空文件），文件系统还会分配一个或多个数据块来存储文件内容。</li><li>这些数据块的信息也会被记录在inode中。</li></ul><h2 id="查找文件" tabindex="-1">查找文件 <a class="header-anchor" href="#查找文件" aria-label="Permalink to &quot;查找文件&quot;">​</a></h2><p>在Unix和类Unix文件系统中，通过inode号查找文件数据的过程涉及到读取inode结构以获取文件存储位置的信息，然后根据这些信息访问文件的实际数据。下面是这个过程的详细步骤：</p><p><strong>1. 定位inode</strong></p><ul><li>当系统知道了文件的inode号后，它首先需要定位并读取这个inode。</li><li>文件系统中的每个inode都有一个固定的位置，通常在一个称为inode表的专用区域。</li><li>文件系统通过inode号直接索引到inode表，定位到对应的inode结构。</li></ul><p><strong>2. 读取inode信息</strong></p><ul><li>每个inode包含了文件的元数据，这些元数据包括但不限于文件大小、权限、所有者、时间戳。</li><li>更重要的是，inode包含了文件数据的存储位置。这些位置信息可能是直接指向数据块的指针，也可能是间接指针，这取决于文件的大小。</li></ul><p><strong>3. 文件数据的存储方式</strong></p><ul><li>对于小文件，inode可能直接包含指向数据块的指针（直接指针）。</li><li>对于较大的文件，inode将包含指向一个或多个间接块的指针，这些间接块又包含指向实际数据块的指针（间接指针、二级间接指针、甚至三级间接指针）。</li></ul><p><strong>4. 访问数据块</strong></p><ul><li>系统根据inode中的信息找到存储文件数据的数据块(磁盘中的真实数据)。</li><li>对于直接指针，系统可以直接访问这些数据块。</li><li>对于间接指针，系统首先访问指针指向的间接块，然后通过间接块找到实际的数据块。</li></ul><p><strong>5. 读取文件数据</strong></p><ul><li>一旦找到数据块，系统就可以读取这些块中存储的文件数据。</li></ul><div class="info custom-block"><p class="custom-block-title">INFO</p><p>实例 假设一个文件的inode号是5，文件系统会执行以下操作：</p><p>1.在inode表中找到编号为5的inode。</p><p>2.读取inode 5的内容，获取文件的大小、权限和数据块位置等信息。</p><p>3.如果文件较小，直接读取inode中记录的数据块。</p><p>4.如果文件较大，遵循inode中的间接指针，找到实际的数据块。</p><p>5.从这些数据块中读取文件数据。</p></div><p>总之，通过inode号查找文件数据是一种有效且组织良好的过程，它允许文件系统快速定位并访问存储在磁盘上的文件数据。</p><h2 id="修改文件" tabindex="-1">修改文件 <a class="header-anchor" href="#修改文件" aria-label="Permalink to &quot;修改文件&quot;">​</a></h2><p>修改文件时，文件系统会根据需要更新文件的inode和数据块（datablocks）。这个过程涉及到对文件内容的修改以及对文件元数据的更新。以下是一般的流程：</p><p><strong>1. 打开文件进行修改</strong></p><ul><li>当一个文件被打开并准备修改时，文件系统首先定位到该文件的inode。</li><li>通过inode，文件系统获取文件的元数据，如文件大小、权限、以及指向数据块的指针。</li></ul><p><strong>2. 修改文件数据</strong></p><ul><li>文件修改通常涉及到对文件数据的写入。这可能发生在已存在的数据块中，或者需要分配新的数据块。</li><li>如果文件内容增加导致现有的数据块不足以容纳新数据，文件系统将分配新的数据块来存储额外的内容。</li><li>当文件缩小并且某些数据块不再需要时，文件系统会释放这些数据块。这意味着这些数据块现在可以被文件系统用于其他文件或目录。</li></ul><p><strong>3. 更新数据块</strong></p><ul><li>如果修改发生在已有的数据块中，那么这些块的内容将被更新。</li><li>如果有新的数据块被分配，文件系统将更新块位图（block bitmap），标记这些新分配的块为已使用。</li><li>如果有释放的数据块，相应的位在块位图中会被设置为0，表示这些块现在是空闲的。</li><li>文件系统还会更新inode中的数据块指针，以反映对数据块的更改。</li></ul><p><strong>4. 更新inode</strong></p><ul><li>修改文件后，文件系统会更新inode中的相关信息，如文件大小和修改时间。</li><li>如果文件修改涉及到新增数据块，inode中的指针将被更新以指向这些新分配的块。</li></ul><p><strong>5. 写回更改</strong></p><ul><li>对数据块和inode的更改最终会被写回存储设备，确保修改被持久化。</li></ul><p><strong>6. 关闭文件</strong> 完成修改后，文件被关闭。这时，所有对文件的修改都已经被更新到文件系统中。</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p><strong>注意点</strong></p><ul><li>这个过程可能略有不同，具体取决于文件系统的类型（如ext4、XFS、Btrfs等）和操作系统的具体实现。</li><li>现代文件系统可能会采用更复杂的策略，如写时复制（Copy-on-Write），延迟分配等，以优化性能和提高数据的完整性。</li></ul><p>总之，文件修改涉及到对文件内容的实际更改以及对文件系统中记录这些内容（如inode和数据块）的更新。</p></div><h2 id="删除文件" tabindex="-1">删除文件 <a class="header-anchor" href="#删除文件" aria-label="Permalink to &quot;删除文件&quot;">​</a></h2><ul><li><p>更新目录项：从包含该文件的目录中移除对应的目录项（directory entry）。这个操作涉及到更新目录文件，删除文件名和它对应的inode号的引用。</p></li><li><p>减少inode引用计数：每个文件都有一个与之关联的inode，其中存储了文件的元数据。删除文件时，系统会减少该inode的引用计数。</p></li><li><p>释放inode：如果inode的引用计数降至0（没有任何目录项或其他文件系统链接指向它），系统将在inode bitmap中将对应的位置为0，表示该inode现在是空闲的。</p></li><li><p>释放数据块：如果inode不再被使用（引用计数为0），系统还需要释放该inode所指向的所有数据块，并在数据块的bitmap中相应地标记为未使用。</p></li><li><p>更新其他元数据：可能需要更新其他文件系统元数据，如超级块（superblock）中的空闲inode和空闲数据块计数等。</p></li></ul><blockquote><p>引用计数和链接有关</p></blockquote>',51),d=[t];function a(r,p,s,u,c,h){return o(),e("div",null,d)}const g=i(n,[["render",a]]);export{m as __pageData,g as default};
